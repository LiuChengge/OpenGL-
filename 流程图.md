```mermaid
graph TD
    subgraph Camera_Timeline [相机数据流 (60Hz)]
        CamFrame1[相机帧 N-1] -->|16.6ms| CamFrame2[相机帧 N <br>最新!]
        CamFrame2 -->|16.6ms| CamFrame3[相机帧 N+1]
    end

    subgraph Vulkan_Pipeline [Vulkan 极速管线 (87ms)]
        direction TB
        V_Start(循环开始)
        
        V_Wait[<b>1. vkWaitForFences</b><br>阻塞CPU直到上一帧显示完毕<br>CPU在VSync后刚被唤醒]
        style V_Wait fill:#ffcccc,stroke:#333
        
        V_Sample[<b>2. 读取相机数据</b><br>关键: 等待结束时刻读取<br>极大概率读到<b>相机帧 N</b>]
        style V_Sample fill:#ccffcc,stroke:#333,stroke-width:2px
        
        V_Upload[3. memcpy 到 Staging Buffer<br>耗时 < 1ms]
        
        V_Submit[4. vkQueueSubmit & Present<br>非阻塞提交]
        
        V_Direct[<b>5. Direct Scanout</b><br>绕过DWM合成器<br>缓冲深度: ~1-2帧]
        style V_Direct fill:#e1f5fe,stroke:#333
        
        V_Display(显示画面)
        
        V_Start --> V_Wait --> V_Sample --> V_Upload --> V_Submit --> V_Direct --> V_Display
    end

    subgraph OpenGL_Pipeline [OpenGL 滞后管线 (134ms)]
        direction TB
        GL_Start(循环开始)
        
        GL_Sample[<b>1. 读取相机数据</b><br>关键: 在所有等待之前读取<br>读到<b>相机帧 N-1</b> (旧数据)]
        style GL_Sample fill:#ffecb3,stroke:#333,stroke-width:2px
        
        GL_Upload[2. glTexSubImage2D<br>驱动内部拷贝 overhead]
        
        GL_Draw[3. glDrawElements]
        
        GL_Finish[<b>4. glFinish</b><br>强制CPU等待GPU完成<br>管线串行化]
        style GL_Finish fill:#ffcccc,stroke:#333
        
        GL_Swap[<b>5. glfwSwapBuffers</b><br>再次阻塞等待 VSync信号]
        style GL_Swap fill:#ffcccc,stroke:#333
        
        GL_DWM[<b>6. DWM 桌面合成器</b><br>无法绕过 OS<br>强制三重缓冲: +3帧延迟]
        style GL_DWM fill:#ef9a9a,stroke:#333
        
        GL_Display(显示画面)
        
        GL_Start --> GL_Sample --> GL_Upload --> GL_Draw --> GL_Finish --> GL_Swap --> GL_DWM --> GL_Display
    end

    %% 关联线
    CamFrame2 -.->|命中| V_Sample
    CamFrame1 -.->|陈旧数据| GL_Sample
```