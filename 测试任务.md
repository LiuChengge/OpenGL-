# 延迟分析验证实验计划

## 实验总览

| 实验编号 | 实验名称 | 验证目标 | 优先级 |
|----------|----------|----------|--------|
| E1 | vkDeviceWaitIdle替换实验 | 确定WaitIdle的额外等待时间 | **高** |
| E2 | Vulkan时间戳精确测量 | GPU各阶段精确耗时 | **高** |
| E3 | OpenGL帧队列深度探测 | 驱动缓冲帧数 | **高** |
| E4 | 60Hz帧间隔分布测量 | 补充60Hz数据 | **中** |
| E5 | V4L2缓冲延迟测量 | 相机管线延迟 | **中** |
| E6 | 同步策略对比矩阵 | 系统性对比所有同步组合 | **高** |
| E7 | 呈现时间戳验证 | 帧实际显示时刻 | **中** |

---

## 实验E1：vkDeviceWaitIdle替换实验

### 目的
验证`vkDeviceWaitIdle`相比仅等待fence额外等待了多少时间，确定其是否等待帧实际显示。

### 实验设计

#### 变量控制
| 配置 | 同步方式 | 说明 |
|------|----------|------|
| A（基线） | `vkDeviceWaitIdle` | 当前代码 |
| B | 仅`vkWaitForFences` | 移除WaitIdle |
| C | `vkQueueWaitIdle(presentQueue)` | 仅等待呈现队列 |
| D | 无额外同步 | 移除所有末尾同步 |

#### 代码修改

**文件：`VkDisplay.cpp`，`draw()`函数末尾**

```cpp
// 添加编译宏控制同步策略
#define SYNC_STRATEGY 0  // 0=WaitIdle, 1=FenceOnly, 2=QueueWaitIdle, 3=NoSync

void VkDisplay::draw() {
    // ... 现有代码直到 vkQueuePresentKHR ...
    
    result = vkQueuePresentKHR(presentQueue, &presentInfo);
    
    // ===== 同步策略切换点 =====
#if SYNC_STRATEGY == 0
    // 策略A：完整设备等待（当前基线）
    auto sync_start = std::chrono::high_resolution_clock::now();
    vkDeviceWaitIdle(device);
    auto sync_end = std::chrono::high_resolution_clock::now();
    auto sync_time = std::chrono::duration_cast<std::chrono::microseconds>(sync_end - sync_start).count();
    printf("SYNC_TIME[WaitIdle]: %ld us\n", sync_time);
    
#elif SYNC_STRATEGY == 1
    // 策略B：仅等待当前帧fence（下一帧开始时等待）
    // 不在此处添加额外等待，依赖下一帧的vkWaitForFences
    printf("SYNC_TIME[FenceOnly]: 0 us (deferred)\n");
    
#elif SYNC_STRATEGY == 2
    // 策略C：仅等待呈现队列
    auto sync_start = std::chrono::high_resolution_clock::now();
    vkQueueWaitIdle(presentQueue);
    auto sync_end = std::chrono::high_resolution_clock::now();
    auto sync_time = std::chrono::duration_cast<std::chrono::microseconds>(sync_end - sync_start).count();
    printf("SYNC_TIME[QueueWaitIdle]: %ld us\n", sync_time);
    
#elif SYNC_STRATEGY == 3
    // 策略D：无额外同步
    printf("SYNC_TIME[NoSync]: 0 us\n");
#endif

    currentFrame = (currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;
}
```

#### 测量方法

```bash
# 编译4个版本
for strategy in 0 1 2 3; do
    cmake -DSYNC_STRATEGY=$strategy ..
    make -j8
    cp endo_viewer endo_viewer_sync$strategy
done

# 运行测试（每种配置40组数据）
for strategy in 0 1 2 3; do
    for i in $(seq 1 40); do
        echo "=== Strategy $strategy, Run $i ===" >> results_e1.log
        timeout 10s ./endo_viewer_sync$strategy 2>&1 | grep -E "SYNC_TIME|FRAME_PROFILE" >> results_e1.log
    done
done
```

#### 示波器测量
- 同时使用光电传感器测量端到端延迟
- 每种策略测量40组数据
- 记录：均值、方差、极值

### 预期结果与解读

| 结果 | 含义 |
|------|------|
| B与A差异≈8ms（60Hz） | 确认WaitIdle等待了额外~8ms（半个VSync周期） |
| B与A差异≈16ms（60Hz） | WaitIdle等待了完整VSync周期（帧显示完成） |
| C与A差异≈0 | WaitIdle主要等待呈现队列 |
| C与A差异>0 | WaitIdle还等待了图形队列 |
| D出现画面撕裂 | 说明同步是必要的 |

### 数据记录模板

```
实验E1：vkDeviceWaitIdle替换实验
日期：____________________
显示器刷新率：____________

| 策略 | SYNC_TIME均值(μs) | 端到端延迟均值(ms) | 方差 | 备注 |
|------|-------------------|-------------------|------|------|
| A    |                   |                   |      |      |
| B    |                   |                   |      |      |
| C    |                   |                   |      |      |
| D    |                   |                   |      |      |
```

---

## 实验E2：Vulkan时间戳精确测量

### 目的
使用Vulkan时间戳查询精确测量GPU管线各阶段耗时，消除CPU测量的不确定性。

### 实验设计

#### 需要添加的Vulkan资源

**文件：`VkDisplay.h`，添加成员变量**

```cpp
// 时间戳查询相关
VkQueryPool timestampQueryPool = VK_NULL_HANDLE;
static constexpr int TIMESTAMP_COUNT = 6;  // 每帧6个时间戳
float timestampPeriod = 0.0f;  // 纳秒/tick

// 时间戳索引定义
enum TimestampIndex {
    TS_FRAME_START = 0,
    TS_UPLOAD_COMPLETE = 1,
    TS_RENDER_START = 2,
    TS_RENDER_END = 3,
    TS_PRESENT_SUBMIT = 4,
    TS_FRAME_END = 5
};
```

#### 创建查询池

**文件：`VkDisplay.cpp`，添加新函数**

```cpp
void VkDisplay::createTimestampQueryPool() {
    // 获取时间戳精度
    VkPhysicalDeviceProperties properties;
    vkGetPhysicalDeviceProperties(physicalDevice, &properties);
    timestampPeriod = properties.limits.timestampPeriod;
    
    printf("GPU Timestamp Period: %.2f ns/tick\n", timestampPeriod);
    
    // 检查时间戳支持
    if (timestampPeriod == 0) {
        printf("WARNING: GPU does not support timestamps!\n");
        return;
    }
    
    // 创建查询池
    VkQueryPoolCreateInfo queryPoolInfo{};
    queryPoolInfo.sType = VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO;
    queryPoolInfo.queryType = VK_QUERY_TYPE_TIMESTAMP;
    queryPoolInfo.queryCount = TIMESTAMP_COUNT * MAX_FRAMES_IN_FLIGHT;
    
    if (vkCreateQueryPool(device, &queryPoolInfo, nullptr, &timestampQueryPool) != VK_SUCCESS) {
        throw std::runtime_error("Failed to create timestamp query pool!");
    }
}
```

#### 修改命令缓冲区录制

**文件：`VkDisplay.cpp`，`recordCommandBuffer()`函数**

```cpp
void VkDisplay::recordCommandBuffer(VkCommandBuffer commandBuffer, uint32_t imageIndex) {
    VkCommandBufferBeginInfo beginInfo{};
    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    
    if (vkBeginCommandBuffer(commandBuffer, &beginInfo) != VK_SUCCESS) {
        throw std::runtime_error("Failed to begin recording command buffer!");
    }
    
    // 重置本帧的时间戳查询
    uint32_t queryOffset = currentFrame * TIMESTAMP_COUNT;
    vkCmdResetQueryPool(commandBuffer, timestampQueryPool, queryOffset, TIMESTAMP_COUNT);
    
    // TS0: 帧开始
    vkCmdWriteTimestamp(commandBuffer, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, 
                        timestampQueryPool, queryOffset + TS_FRAME_START);
    
    // === 纹理上传（barrier + copy）===
    // ... 现有的barrier和copy代码 ...
    
    // TS1: 上传完成
    vkCmdWriteTimestamp(commandBuffer, VK_PIPELINE_STAGE_TRANSFER_BIT,
                        timestampQueryPool, queryOffset + TS_UPLOAD_COMPLETE);
    
    // === 渲染通道 ===
    VkRenderPassBeginInfo renderPassInfo{};
    // ... 现有代码 ...
    
    vkCmdBeginRenderPass(commandBuffer, &renderPassInfo, VK_SUBPASS_CONTENTS_INLINE);
    
    // TS2: 渲染开始
    vkCmdWriteTimestamp(commandBuffer, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
                        timestampQueryPool, queryOffset + TS_RENDER_START);
    
    // ... 绑定管线、绘制命令 ...
    vkCmdDraw(commandBuffer, 6, 1, 0, 0);
    
    // TS3: 渲染结束
    vkCmdWriteTimestamp(commandBuffer, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
                        timestampQueryPool, queryOffset + TS_RENDER_END);
    
    vkCmdEndRenderPass(commandBuffer);
    
    // TS4: 命令缓冲结束（呈现提交前）
    vkCmdWriteTimestamp(commandBuffer, VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
                        timestampQueryPool, queryOffset + TS_PRESENT_SUBMIT);
    
    if (vkEndCommandBuffer(commandBuffer) != VK_SUCCESS) {
        throw std::runtime_error("Failed to record command buffer!");
    }
}
```

#### 读取时间戳

**文件：`VkDisplay.cpp`，`draw()`函数中添加**

```cpp
void VkDisplay::draw() {
    // 等待上一帧完成
    vkWaitForFences(device, 1, &inFlightFences[currentFrame], VK_TRUE, UINT64_MAX);
    
    // ===== 读取上一帧的时间戳 =====
    if (timestampQueryPool != VK_NULL_HANDLE) {
        uint32_t prevFrame = (currentFrame + MAX_FRAMES_IN_FLIGHT - 1) % MAX_FRAMES_IN_FLIGHT;
        uint32_t queryOffset = prevFrame * TIMESTAMP_COUNT;
        
        uint64_t timestamps[TIMESTAMP_COUNT];
        VkResult result = vkGetQueryPoolResults(
            device, timestampQueryPool, queryOffset, TIMESTAMP_COUNT,
            sizeof(timestamps), timestamps, sizeof(uint64_t),
            VK_QUERY_RESULT_64_BIT | VK_QUERY_RESULT_WAIT_BIT
        );
        
        if (result == VK_SUCCESS) {
            // 转换为微秒
            auto toMicros = [this](uint64_t start, uint64_t end) -> double {
                return (end - start) * timestampPeriod / 1000.0;
            };
            
            printf("GPU_TIMESTAMP: upload=%.1fus, render=%.1fus, total=%.1fus\n",
                   toMicros(timestamps[TS_FRAME_START], timestamps[TS_UPLOAD_COMPLETE]),
                   toMicros(timestamps[TS_RENDER_START], timestamps[TS_RENDER_END]),
                   toMicros(timestamps[TS_FRAME_START], timestamps[TS_PRESENT_SUBMIT]));
        }
    }
    
    // ... 后续代码 ...
}
```

### 测量脚本

```bash
#!/bin/bash
# run_e2.sh - Vulkan时间戳实验

OUTPUT_FILE="results_e2_$(date +%Y%m%d_%H%M%S).log"

echo "=== Vulkan GPU Timestamp Experiment ===" > $OUTPUT_FILE
echo "Date: $(date)" >> $OUTPUT_FILE
echo "" >> $OUTPUT_FILE

# 运行测试，采集1000帧数据
timeout 60s ./endo_viewer 2>&1 | grep "GPU_TIMESTAMP" | head -1000 >> $OUTPUT_FILE

# 统计分析
echo "" >> $OUTPUT_FILE
echo "=== Statistics ===" >> $OUTPUT_FILE
grep "GPU_TIMESTAMP" $OUTPUT_FILE | awk -F'[=,]' '{
    upload += $2; render += $4; total += $6; n++
} END {
    printf "Upload: mean=%.1fus\n", upload/n
    printf "Render: mean=%.1fus\n", render/n
    printf "Total:  mean=%.1fus\n", total/n
}'  >> $OUTPUT_FILE
```

### 预期结果

| 阶段 | 预期时间 | 说明 |
|------|----------|------|
| Upload（纹理传输） | 500-1500μs | Staging到Device的DMA传输 |
| Render（实际渲染） | 200-500μs | 简单的全屏四边形 |
| Total（GPU管线） | 1000-3000μs | 远小于CPU测量的5200μs |

**关键验证**：如果GPU Total远小于CPU测量的draw时间（5200μs），则差值是`vkDeviceWaitIdle`的等待时间。

---

## 实验E3：OpenGL帧队列深度探测

### 目的
确定OpenGL驱动内部维护的帧缓冲队列深度。

### 实验设计

#### 方法1：Fence完成时间追踪（增强版）

**修改`GLDisplay.cpp`的`checkFrameLatency()`函数**

```cpp
void GLDisplay::checkFrameLatency() {
    // 扩展追踪：记录每帧从SwapBuffers到fence完成的时间
    static int frame_count = 0;
    static std::vector<long> latencies;
    static std::vector<int> queue_depths;
    
    // 检查所有未完成的fence
    int pending_count = 0;
    for (int i = 0; i < MAX_TRACKED_FRAMES; i++) {
        if (frame_fences[i] != nullptr) {
            GLenum status = glClientWaitSync(frame_fences[i], 0, 0);
            if (status == GL_TIMEOUT_EXPIRED) {
                pending_count++;  // 仍在GPU/驱动队列中
            } else if (status == GL_ALREADY_SIGNALED || status == GL_CONDITION_SATISFIED) {
                // 计算延迟
                auto now = std::chrono::steady_clock::now();
                auto latency = std::chrono::duration_cast<std::chrono::microseconds>(
                    now - swap_timestamps[i]).count();
                latencies.push_back(latency);
                
                glDeleteSync(frame_fences[i]);
                frame_fences[i] = nullptr;
            }
        }
    }
    
    queue_depths.push_back(pending_count);
    
    // 每100帧输出统计
    if (++frame_count % 100 == 0) {
        // 计算队列深度分布
        int depth_hist[10] = {0};
        for (int d : queue_depths) {
            if (d < 10) depth_hist[d]++;
        }
        
        printf("QUEUE_DEPTH_HIST: ");
        for (int i = 0; i < 10; i++) {
            if (depth_hist[i] > 0) {
                printf("[%d]=%d ", i, depth_hist[i]);
            }
        }
        printf("\n");
        
        // 计算延迟统计
        if (!latencies.empty()) {
            long sum = 0, min_val = LONG_MAX, max_val = 0;
            for (long l : latencies) {
                sum += l;
                min_val = std::min(min_val, l);
                max_val = std::max(max_val, l);
            }
            printf("FENCE_LATENCY: mean=%ldus, min=%ldus, max=%ldus, n=%zu\n",
                   sum / latencies.size(), min_val, max_val, latencies.size());
        }
        
        queue_depths.clear();
        latencies.clear();
    }
}
```

#### 方法2：强制队列排空测试

**添加新测试模式**

```cpp
// GLDisplay.h 添加
void testQueueDepth();

// GLDisplay.cpp 实现
void GLDisplay::testQueueDepth() {
    printf("=== Queue Depth Test ===\n");
    
    glfwMakeContextCurrent(windows[0]);
    
    // 快速提交多帧，不等待
    const int TEST_FRAMES = 20;
    GLsync fences[TEST_FRAMES];
    auto submit_times[TEST_FRAMES];
    
    for (int i = 0; i < TEST_FRAMES; i++) {
        // 最小化渲染负载
        glClear(GL_COLOR_BUFFER_BIT);
        
        submit_times[i] = std::chrono::steady_clock::now();
        glfwSwapBuffers(windows[0]);
        fences[i] = glFenceSync(GL_SYNC_GPU_COMMANDS_COMPLETE, 0);
        
        // 不等待，立即提交下一帧
    }
    
    // 等待所有帧完成
    printf("Submitted %d frames, waiting for completion...\n", TEST_FRAMES);
    
    for (int i = 0; i < TEST_FRAMES; i++) {
        glClientWaitSync(fences[i], GL_SYNC_FLUSH_COMMANDS_BIT, UINT64_MAX);
        auto complete_time = std::chrono::steady_clock::now();
        auto latency = std::chrono::duration_cast<std::chrono::microseconds>(
            complete_time - submit_times[i]).count();
        printf("Frame %2d: latency=%6ldus (%.2fms)\n", i, latency, latency/1000.0);
        glDeleteSync(fences[i]);
    }
    
    // 分析队列深度
    // 如果帧0-2延迟相近且都较高，说明队列深度≥3
    // 如果帧3+延迟突然下降，说明队列深度=3
    
    glfwMakeContextCurrent(NULL);
}
```

### 测量执行

```bash
#!/bin/bash
# run_e3.sh - OpenGL队列深度实验

# 测试1：正常运行时的队列深度分布
echo "=== Test 1: Runtime Queue Depth ===" > results_e3.log
timeout 30s ./endo_viewer 2>&1 | grep -E "QUEUE_DEPTH|FENCE_LATENCY" >> results_e3.log

# 测试2：队列排空测试（需要添加命令行参数支持）
echo "" >> results_e3.log
echo "=== Test 2: Queue Drain Test ===" >> results_e3.log
./endo_viewer --test-queue-depth 2>&1 >> results_e3.log
```

### 预期结果

| 队列深度 | 含义 |
|----------|------|
| 0-1 | 驱动不缓冲，每帧等待VSync |
| 2 | 双缓冲，标准配置 |
| 3 | 三缓冲，额外延迟~16ms |
| >3 | 异常，可能驱动bug |

**验证点**：如果队列深度=2，则解释了OpenGL比Vulkan多~33ms延迟（2帧×16.67ms）。

---

## 实验E4：60Hz帧间隔分布测量

### 目的
补充60Hz显示器下的帧间隔数据，验证VSync行为。

### 实验设计

#### 代码修改

**文件：`GLDisplay.cpp`，`renderWindowContext()`函数**

已有代码可用，只需确保在60Hz下运行：

```cpp
// 已存在的测量代码
static auto last_frame_time = std::chrono::steady_clock::now();
if (windowIndex == 0) {
    auto current_time = std::chrono::steady_clock::now();
    auto frame_interval = std::chrono::duration_cast<std::chrono::microseconds>(
        current_time - last_frame_time).count();
    last_frame_time = current_time;
    printf("FRAME_INTERVAL: %ld us (%.2f ms)\n", frame_interval, frame_interval / 1000.0);
}
```

**Vulkan版本添加相同测量**

```cpp
// VkDisplay.cpp draw()函数开头
void VkDisplay::draw() {
    static auto last_frame_time = std::chrono::steady_clock::now();
    auto current_time = std::chrono::steady_clock::now();
    auto frame_interval = std::chrono::duration_cast<std::chrono::microseconds>(
        current_time - last_frame_time).count();
    last_frame_time = current_time;
    printf("VK_FRAME_INTERVAL: %ld us (%.2f ms)\n", frame_interval, frame_interval / 1000.0);
    
    // ... 现有代码 ...
}
```

### 测量执行

```bash
#!/bin/bash
# run_e4.sh - 60Hz帧间隔测量

# 确保显示器设置为60Hz
xrandr --output <DISPLAY_NAME> --mode 1920x1080 --rate 60

# Vulkan 60Hz
echo "=== Vulkan 60Hz ===" > results_e4.log
timeout 30s ./endo_viewer_vulkan 2>&1 | grep "VK_FRAME_INTERVAL" | head -500 >> results_e4.log

# OpenGL 60Hz  
echo "" >> results_e4.log
echo "=== OpenGL 60Hz ===" >> results_e4.log
timeout 30s ./endo_viewer_opengl 2>&1 | grep "FRAME_INTERVAL" | head -500 >> results_e4.log

# 分析脚本
python3 << 'EOF'
import re
import numpy as np

def analyze_intervals(filename, pattern):
    intervals = []
    with open(filename) as f:
        for line in f:
            match = re.search(pattern + r': (\d+) us', line)
            if match:
                intervals.append(int(match.group(1)))
    
    if intervals:
        arr = np.array(intervals)
        print(f"  Mean: {arr.mean():.1f} us ({arr.mean()/1000:.2f} ms)")
        print(f"  Std:  {arr.std():.1f} us")
        print(f"  Min:  {arr.min()} us")
        print(f"  Max:  {arr.max()} us")
        
        # 分布直方图
        hist, bins = np.histogram(arr, bins=[0, 5000, 10000, 15000, 20000, 25000, 50000])
        print(f"  Distribution:")
        print(f"    0-5ms:   {hist[0]} ({100*hist[0]/len(arr):.1f}%)")
        print(f"    5-10ms:  {hist[1]} ({100*hist[1]/len(arr):.1f}%)")
        print(f"    10-15ms: {hist[2]} ({100*hist[2]/len(arr):.1f}%)")
        print(f"    15-20ms: {hist[3]} ({100*hist[3]/len(arr):.1f}%)")
        print(f"    20-25ms: {hist[4]} ({100*hist[4]/len(arr):.1f}%)")
        print(f"    >25ms:   {hist[5]} ({100*hist[5]/len(arr):.1f}%)")

print("Vulkan 60Hz:")
analyze_intervals("results_e4.log", "VK_FRAME_INTERVAL")
print("\nOpenGL 60Hz:")
analyze_intervals("results_e4.log", "FRAME_INTERVAL")
EOF
```

### 预期结果

| 配置 | 预期帧间隔分布 |
|------|----------------|
| Vulkan+60Hz | 主要集中在16-17ms（VSync锁定） |
| OpenGL+60Hz | 可能更分散（驱动缓冲影响） |

**验证点**：
- 如果Vulkan帧间隔严格=16.67ms，确认VSync锁定
- 如果OpenGL帧间隔<16.67ms且稳定，说明驱动缓冲绕过了VSync等待

---

## 实验E5：V4L2缓冲延迟测量

### 目的
测量相机管线（曝光→V4L2驱动→用户空间）的延迟，消除这部分不确定性。

### 实验设计

#### 方法1：帧时间戳分析

**修改`v4l2_capture.h`/`v4l2_capture.cpp`**

```cpp
// 在V4L2Capture类中添加时间戳记录
struct FrameTimestamp {
    struct timeval v4l2_timestamp;  // 内核捕获时间
    std::chrono::steady_clock::time_point dequeue_time;  // 出队时间
};

bool V4L2Capture::ioctlDequeueBuffers(unsigned char* data, FrameTimestamp* ts = nullptr) {
    struct v4l2_buffer buf;
    memset(&buf, 0, sizeof(buf));
    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    buf.memory = V4L2_MEMORY_MMAP;
    
    if (ioctl(fd, VIDIOC_DQBUF, &buf) < 0) {
        return false;
    }
    
    if (ts) {
        ts->v4l2_timestamp = buf.timestamp;
        ts->dequeue_time = std::chrono::steady_clock::now();
    }
    
    // ... 数据拷贝 ...
    
    return true;
}
```

**修改`endo_viewer.cpp`的`readLeftImage()`**

```cpp
void EndoViewer::readLeftImage(int index) {
    // ...
    
    while(_keep_running) {
        auto time_start = ::getCurrentTimePoint();
        
        FrameTimestamp ts;
        int write_idx = _write_index_l.load(std::memory_order_relaxed);
        flag = _cap_l->ioctlDequeueBuffers(_image_l_buffers[write_idx].data, &ts);
        
        if (flag) {
            // 计算V4L2内部延迟
            // V4L2时间戳是从系统启动开始的秒+微秒
            auto v4l2_time_us = ts.v4l2_timestamp.tv_sec * 1000000LL + ts.v4l2_timestamp.tv_usec;
            
            // 转换dequeue_time到相同的时间基准（需要获取系统启动时间）
            auto now_us = std::chrono::duration_cast<std::chrono::microseconds>(
                ts.dequeue_time.time_since_epoch()).count();
            
            // 简化：直接计算连续帧的时间戳差值
            static long last_v4l2_time = 0;
            static auto last_dequeue_time = ts.dequeue_time;
            
            if (last_v4l2_time > 0) {
                long v4l2_delta = v4l2_time_us - last_v4l2_time;
                auto dequeue_delta = std::chrono::duration_cast<std::chrono::microseconds>(
                    ts.dequeue_time - last_dequeue_time).count();
                
                printf("V4L2_TIMING: v4l2_delta=%ldus, dequeue_delta=%ldus, diff=%ldus\n",
                       v4l2_delta, dequeue_delta, dequeue_delta - v4l2_delta);
            }
            
            last_v4l2_time = v4l2_time_us;
            last_dequeue_time = ts.dequeue_time;
        }
        
        // ...
    }
}
```

#### 方法2：LED闪烁同步测试

**硬件准备**：
- 在相机视野中放置LED
- 使用GPIO或Arduino控制LED闪烁
- 记录LED触发时间戳

**软件修改**：

```cpp
// 添加LED检测（简单亮度阈值）
bool detectLED(const cv::Mat& frame, cv::Point& center) {
    cv::Mat gray;
    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);
    
    double minVal, maxVal;
    cv::Point minLoc, maxLoc;
    cv::minMaxLoc(gray, &minVal, &maxVal, &minLoc, &maxLoc);
    
    if (maxVal > 240) {  // LED亮
        center = maxLoc;
        return true;
    }
    return false;
}

// 在readLeftImage中添加检测
if (flag) {
    cv::Point led_pos;
    bool led_on = detectLED(_image_l_buffers[write_idx], led_pos);
    
    static bool last_led_on = false;
    if (led_on && !last_led_on) {
        // LED刚刚亮起，记录时间
        auto led_detect_time = std::chrono::steady_clock::now();
        printf("LED_DETECTED: frame_time=%ld, v4l2_ts=%ld.%06ld\n",
               std::chrono::duration_cast<std::chrono::microseconds>(
                   led_detect_time.time_since_epoch()).count(),
               ts.v4l2_timestamp.tv_sec, ts.v4l2_timestamp.tv_usec);
    }
    last_led_on = led_on;
}
```

### 测量执行

```bash
#!/bin/bash
# run_e5.sh - V4L2延迟测量

# 方法1：时间戳分析
echo "=== V4L2 Timestamp Analysis ===" > results_e5.log
timeout 30s ./endo_viewer 2>&1 | grep "V4L2_TIMING" | head -200 >> results_e5.log

# 统计分析
echo "" >> results_e5.log
grep "V4L2_TIMING" results_e5.log | awk -F'[=,]' '{
    sum += $6; n++
} END {
    printf "V4L2 Buffer Delay: mean=%.1fus (%.2fms)\n", sum/n, sum/n/1000
}' >> results_e5.log
```

### 预期结果

| 指标 | 预期值 | 说明 |
|------|--------|------|
| V4L2帧间隔 | ~16.67ms | 60Hz相机 |
| 出队延迟 | 1-5ms | USB传输+驱动处理 |
| 缓冲深度 | 2-4帧 | V4L2默认配置 |

---

## 实验E6：同步策略对比矩阵

### 目的
系统性对比所有同步策略组合，建立完整的延迟模型。

### 实验设计

#### 配置矩阵

| 编号 | 后端 | 刷新率 | 同步策略 | VSync |
|------|------|--------|----------|-------|
| C1 | Vulkan | 165Hz | WaitIdle | FIFO |
| C2 | Vulkan | 165Hz | FenceOnly | FIFO |
| C3 | Vulkan | 165Hz | WaitIdle | Mailbox |
| C4 | Vulkan | 60Hz | WaitIdle | FIFO |
| C5 | Vulkan | 60Hz | FenceOnly | FIFO |
| C6 | OpenGL | 165Hz | glFinish+VSync | On |
| C7 | OpenGL | 165Hz | glFinish | Off |
| C8 | OpenGL | 165Hz | NoSync+VSync | On |
| C9 | OpenGL | 60Hz | glFinish+VSync | On |
| C10 | OpenGL | 60Hz | glFinish | Off |

#### 自动化测试脚本

```bash
#!/bin/bash
# run_e6.sh - 同步策略矩阵测试

RESULTS_DIR="results_e6_$(date +%Y%m%d_%H%M%S)"
mkdir -p $RESULTS_DIR

# 配置数组
declare -A configs
configs["C1"]="vulkan 165 waitidle fifo"
configs["C2"]="vulkan 165 fenceonly fifo"
configs["C3"]="vulkan 165 waitidle mailbox"
configs["C4"]="vulkan 60 waitidle fifo"
configs["C5"]="vulkan 60 fenceonly fifo"
configs["C6"]="opengl 165 glfinish vsync_on"
configs["C7"]="opengl 165 glfinish vsync_off"
configs["C8"]="opengl 165 nosync vsync_on"
configs["C9"]="opengl 60 glfinish vsync_on"
configs["C10"]="opengl 60 glfinish vsync_off"

# 运行每个配置
for config_id in "${!configs[@]}"; do
    read backend refresh sync vsync <<< "${configs[$config_id]}"
    
    echo "=== Testing $config_id: $backend $refresh Hz, $sync, $vsync ==="
    
    # 设置显示器刷新率
    xrandr --output <DISPLAY> --mode 1920x1080 --rate $refresh
    sleep 2
    
    # 编译对应版本
    cmake -DBACKEND=$backend -DSYNC_STRATEGY=$sync -DVSYNC=$vsync ..
    make -j8
    
    # 运行测试（40组，每组10秒）
    for run in $(seq 1 40); do
        echo "Run $run/40..."
        timeout 10s ./endo_viewer 2>&1 > "$RESULTS_DIR/${config_id}_run${run}.log"
        
        # 同时进行示波器测量（手动记录或自动化）
        # TODO: 集成示波器自动化读取
        
        sleep 2
    done
done

# 汇总结果
echo "=== Summary ===" > "$RESULTS_DIR/summary.txt"
for config_id in "${!configs[@]}"; do
    echo "$config_id:" >> "$RESULTS_DIR/summary.txt"
    # 提取CPU测量的延迟数据
    grep "FRAME_PROFILE\|SYNC_TIME" "$RESULTS_DIR/${config_id}_run"*.log | \
        awk '{...}' >> "$RESULTS_DIR/summary.txt"
done
```

### 数据记录表格

```
实验E6：同步策略对比矩阵
日期：____________________

| 配置 | 端到端延迟(ms) | CPU处理(ms) | 同步等待(ms) | 方差 |
|------|---------------|-------------|-------------|------|
| C1   |               |             |             |      |
| C2   |               |             |             |      |
| ...  |               |             |             |      |
```

---

## 实验E7：呈现时间戳验证

### 目的
使用显示子系统API获取帧实际呈现到屏幕的时间戳。

### 实验设计

#### Vulkan方法：VK_GOOGLE_display_timing扩展

```cpp
// 检查扩展支持
bool supportsDisplayTiming = false;
// 在createLogicalDevice中检查

// 获取呈现时间
VkPastPresentationTimingGOOGLE timings[10];
uint32_t count = 10;
vkGetPastPresentationTimingGOOGLE(device, swapChain, &count, timings);

for (uint32_t i = 0; i < count; i++) {
    printf("PRESENT_TIMING: presentID=%u, desiredPresentTime=%lu, actualPresentTime=%lu, "
           "earliestPresentTime=%lu, presentMargin=%lu\n",
           timings[i].presentID,
           timings[i].desiredPresentTime,
           timings[i].actualPresentTime,
           timings[i].earliestPresentTime,
           timings[i].presentMargin);
}
```

#### OpenGL方法：GLX_OML_sync_control

```cpp
// 检查扩展支持
if (glfwExtensionSupported("GLX_OML_sync_control")) {
    // 获取当前媒体流计数器
    int64_t ust, msc, sbc;
    glXGetSyncValuesOML(display, drawable, &ust, &msc, &sbc);
    
    printf("GLX_SYNC: ust=%ld, msc=%ld, sbc=%ld\n", ust, msc, sbc);
}
```

### 备选方案：外部测量

如果扩展不可用，使用示波器+光电传感器的方法是最可靠的：

```
硬件连接：
1. 光电传感器贴在显示器表面
2. 传感器输出连接示波器CH1
3. GPIO触发信号连接示波器CH2（标记帧提交时刻）

测量流程：
1. 在代码中SwapBuffers/Present前拉高GPIO
2. SwapBuffers/Present后拉低GPIO
3. 示波器测量GPIO下降沿到光电传感器上升沿的时间
```

---

## 实验执行时间表

| 周 | 实验 | 预计时间 | 依赖 |
|----|------|----------|------|
| 1 | E1（WaitIdle替换） | 2天 | 无 |
| 1 | E2（Vulkan时间戳） | 2天 | 无 |
| 2 | E3（OpenGL队列深度） | 2天 | 无 |
| 2 | E4（60Hz帧间隔） | 1天 | 无 |
| 3 | E5（V4L2延迟） | 2天 | 可能需要硬件 |
| 3-4 | E6（对比矩阵） | 4天 | E1-E5结果 |
| 4 | E7（呈现时间戳） | 2天 | 可选 |

---

## 结果汇总模板

```
===============================================================
                    延迟分析验证实验报告
===============================================================
日期：____________________
实验者：__________________

一、实验E1结果：vkDeviceWaitIdle等待时间
   - WaitIdle额外等待：______ ms
   - 结论：□ 等待VSync  □ 等待帧显示  □ 仅等待GPU

二、实验E2结果：Vulkan GPU精确时间
   - 纹理上传：______ μs
   - 实际渲染：______ μs
   - GPU总计：______ μs
   - 与CPU测量差异：______ μs（此为WaitIdle等待时间）

三、实验E3结果：OpenGL驱动队列深度
   - 测量队列深度：______ 帧
   - 对应延迟：______ ms

四、实验E4结果：60Hz帧间隔分布
   - Vulkan主要帧间隔：______ ms
   - OpenGL主要帧间隔：______ ms

五、实验E5结果：V4L2管线延迟
   - 相机到用户空间延迟：______ ms
   - V4L2缓冲深度：______ 帧

六、综合延迟模型修正

| 组成部分 | 原估计 | 实测值 | 修正 |
|----------|--------|--------|------|
| 相机延迟 |        |        |      |
| CPU处理  |        |        |      |
| GPU渲染  |        |        |      |
| 同步等待 |        |        |      |
| 驱动队列 |        |        |      |
| 显示响应 |        |        |      |

七、原分析验证结论
   - 8.58ms差异（OpenGL+60Hz vs Vulkan+60Hz）：□ 验证  □ 修正为______
   - 47ms差异（Vulkan+165Hz vs OpenGL+165Hz）：□ 验证  □ 修正为______
   - 67ms差异（Vulkan+165Hz vs Vulkan+60Hz）：□ 验证  □ 修正为______
===============================================================
```




这是经过严谨修正后的完整实验计划（E1-E7）。

**主要修正点说明：**

1. **环境明确化**：每个实验都显式规定了**显示器刷新率**（165Hz vs 60Hz）和**内窥镜输入状态**。
2. **E1修正**：增加了 **“策略B+（双缓冲）”**，以防止单纯移除 WaitIdle 后 CPU 只是把等待转移到了下一帧的 Acquire 阶段，导致无法观察差异。
3. **E3修正**：明确了“排空测试”必须在 **VSync OFF** 下进行。
4. **E6修正**：增加了 **`__GL_MaxFramesAllowed=1`** 的测试组，这是验证 OpenGL 延迟根因的“银弹”。

---

# 内窥镜延迟分析验证实验计划 (修订版 v2.0)

## 实验总览

| 实验编号 | 实验名称 | 核心验证目标 | 优先级 |
| --- | --- | --- | --- |
| **E1** | **vkDeviceWaitIdle 替换实验** | 验证 WaitIdle 是否包含显示等待 (Scanout Wait) | **极高** |
| **E2** | **Vulkan 时间戳精确测量** | 确定 GPU 纯渲染耗时 (剥离 WaitIdle 影响) | **高** |
| **E3** | **OpenGL 帧队列深度探测** | 实锤 OpenGL 驱动内部积压了 2-3 帧 | **极高** |
| **E4** | **60Hz 帧间隔分布测量** | 验证 Vulkan 在 60Hz 下的相位锁定效应 | **中** |
| **E5** | **V4L2 缓冲延迟测量** | 确定输入端（相机+驱动）的基础延迟 | **中** |
| **E6** | **全组合同步策略对比** | 系统性对比，验证 `__GL_MaxFramesAllowed` 的效果 | **极高** |
| **E7** | **呈现时间戳验证** | 获取物理呈现时间 (硬件支持依赖) | **低** |

---

## 实验 E1：vkDeviceWaitIdle 替换实验

### 1. 实验目的

验证 `vkDeviceWaitIdle` 导致的额外延迟是否随显示器刷新周期变化，以及它是否阻碍了 CPU/GPU 的并行流水线。

### 2. 测试环境

* **显示器刷新率**：需分别在 **165Hz** 和 **60Hz** 下进行测试。
* **内窥镜输入**：60Hz 实时输入。

### 3. 代码修改 (`VkDisplay.cpp` -> `draw()`)

引入宏 `SYNC_STRATEGY` 控制同步逻辑，并动态调整 `MAX_FRAMES_IN_FLIGHT` (需在头文件配合修改或通过模板实现)。

```cpp
// 伪代码逻辑
void VkDisplay::draw() {
    // ... 提交渲染和呈现 ...
    vkQueuePresentKHR(presentQueue, &presentInfo);

#if SYNC_STRATEGY == 0 // [基准] 原始逻辑
    // 强制串行：等待 GPU 完成 + 可能的显示引擎等待
    vkDeviceWaitIdle(device); 

#elif SYNC_STRATEGY == 1 // [FenceOnly]
    // 移除显式等待，仅依赖下一帧的 vkWaitForFences
    // 注意：如果 MAX_FRAMES_IN_FLIGHT=1，CPU 会在下一帧开头立即阻塞，效果可能与策略0相似
    
#elif SYNC_STRATEGY == 2 // [DoubleBuffer] 关键修正！
    // 移除 WaitIdle，且必须将 MAX_FRAMES_IN_FLIGHT 设为 2
    // 允许 CPU 提前提交下一帧，验证是否能跑得比策略0快
    
#elif SYNC_STRATEGY == 3 // [QueueIdle]
    // 仅等待呈现队列，验证 WaitIdle 是否在等 Graphics 队列
    vkQueueWaitIdle(presentQueue);
#endif
}

```

### 4. 预期结果与解读

| 对比项 | 60Hz 下预期 | 165Hz 下预期 | 结论 |
| --- | --- | --- | --- |
| **B (FenceOnly) vs A** | 差异不大 | 差异不大 | 单缓冲下，移除 WaitIdle 只是转移了等待点。 |
| **C (DoubleBuffer) vs A** | **延迟降低 ~8ms** | 变化不明显 | **关键**：若双缓冲能降低 60Hz 下的延迟，说明 WaitIdle 破坏了流水线并行，是 Vulkan 60Hz 慢的元凶。 |

---

## 实验 E2：Vulkan 时间戳精确测量

### 1. 实验目的

使用 GPU 内部计数器测量渲染耗时，证明 `draw()` 测得的 5.2ms 绝大部分是 CPU 在空转等待。

### 2. 测试环境

* **显示器刷新率**：165Hz (任意频率均可，GPU 内部耗时与刷新率无关)。
* **内窥镜输入**：60Hz。

### 3. 实验步骤

1. 在 `VkDisplay` 中创建 `VkQueryPool` (Type = TIMESTAMP)。
2. 在 `recordCommandBuffer` 中插入 `vkCmdWriteTimestamp`：
* `TS_START`: Top of Pipe
* `TS_UPLOAD_END`: Transfer 阶段结束
* `TS_RENDER_END`: Bottom of Pipe


3. 在 `draw()` 中使用 `vkGetQueryPoolResults` 读取上一帧数据。
4. **注意**：在 `cleanup()` 中销毁 QueryPool。

### 4. 预期结果

* **Upload (GPU)**: ~100-200μs (远小于 CPU 测得的 800μs，证实 DMA 异步)。
* **Render (GPU)**: ~50-100μs (简单的全屏四边形，极快)。
* **结论**：如果 GPU 总耗时 < 1ms，而 CPU `draw()` 耗时 5.2ms，则实锤 `vkDeviceWaitIdle` 浪费了 4ms+。

---

## 实验 E3：OpenGL 帧队列深度探测

### 1. 实验目的

实锤 OpenGL 驱动内部缓冲了 2-3 帧（即 ~33-50ms 延迟的来源）。

### 2. 测试环境

* **显示器刷新率**：**165Hz** (为了能快速排空队列，便于测量)。
* **VSync 状态**：需分别在 **ON** (测运行时深度) 和 **OFF** (测最大容量) 下测试。

### 3. 实验设计

**方法：排空爆发测试 (Drain Burst Test)**

```cpp
void GLDisplay::testQueueDepth() {
    // 1. 暂时关闭 VSync (glfwSwapInterval(0)) 确保 SwapBuffers 不阻塞
    glfwSwapInterval(0); 
    
    // 2. 连续提交 20 帧简单的 glClear，记录每帧 SwapBuffers 返回时间 T_swap
    //    并为每帧插入 Fence
    for(int i=0; i<20; i++) { ... SwapBuffers(); glFenceSync(); ... }
    
    // 3. 测量每个 Fence 的 Signal 时间 T_signal
    // 4. 延迟 L = T_signal - T_swap
}

```

### 4. 预期结果

* **前 2-3 帧**：延迟极低（直接入队，驱动未满）。
* **第 4 帧起**：延迟突然飙升（队列已满，开始阻塞），且延迟值稳定在 `N * 渲染时间`。
* **转折点**即为驱动队列深度。预期 NVIDIA Linux 驱动为 **3 帧**。

---

## 实验 E4：60Hz 帧间隔分布测量

### 1. 实验目的

验证 Vulkan 在 60Hz 下是否发生“相位锁定”（方差极低），以及 OpenGL 是否存在抖动。

### 2. 测试环境

* **显示器刷新率**：**必须严格设置为 60Hz**。
* **内窥镜输入**：60Hz。

### 3. 方法

在 `draw()` 循环中记录 `std::chrono::steady_clock::now()` 的差值。收集 1000 个样本绘制直方图。

### 4. 预期结果

* **Vulkan**: 极其稳定地钉在 16.67ms 或 33.33ms (如果丢帧)，方差极小。
* **OpenGL**: 在 12ms - 20ms 之间波动，表现出驱动队列的“弹性”。

---

## 实验 E5：V4L2 缓冲延迟测量

### 1. 实验目的

确定“光子到光子”延迟的基准底数（Baseline）。

### 2. 测试环境

* **显示器**：任意。
* **相机**：60Hz。

### 3. 方法（推荐方法2：LED物理测量）

* **硬件**：LED灯由 Arduino 控制，每 1秒闪烁一次。Arduino 同时输出电平信号给示波器通道1。
* **软件**：`EndoViewer` 识别画面中 LED 亮起的帧，在识别瞬间翻转 GPIO（或打印高精度日志），连接示波器通道2。
* **测量**：通道1（LED亮）到 通道2（软件识别）的时间差。
* **构成**：曝光时间 (~8ms) + USB 传输 + V4L2 驱动缓冲 + 内存拷贝。

---

## 实验 E6：全组合同步策略对比矩阵 (关键)

### 1. 实验目的

这是最终的验证实验，通过 Grid Search 找到最优解，并验证 `__GL_MaxFramesAllowed` 环境变量的有效性。

### 2. 测试环境

需遍历以下组合。

### 3. 配置矩阵

| ID | API | 显示 Hz | VSync | 关键配置 | 预期延迟 (ms) | 验证目标 |
| --- | --- | --- | --- | --- | --- | --- |
| **C1** | Vulkan | 165 | On | MaxFrames=1 | **~87** | **当前基准 (最优)** |
| **C2** | Vulkan | 60 | On | MaxFrames=1 | ~154 | 验证低刷下的相位惩罚 |
| **C3** | Vulkan | 60 | On | **MaxFrames=2** | **< 154** | **验证双缓冲能否救 60Hz** |
| **C4** | OpenGL | 165 | On | 默认 | ~134 | 当前对照组 |
| **C5** | OpenGL | 165 | Off | 默认 | ~94 | 验证 VSync 队列开销 (~40ms) |
| **C6** | OpenGL | 165 | On | **Env: MaxFrames=1** | **~94** | **验证驱动队列能否被限制** |
| **C7** | OpenGL | 60 | On | 默认 | ~146 | 验证低刷下的流水线优势 |
| **C8** | OpenGL | 60 | On | **Env: MaxFrames=1** | **~?** | 验证低刷下限制队列的后果 |

### 4. 关键操作

对于 C6 和 C8，在运行程序前执行：

```bash
export __GL_MaxFramesAllowed=1
./endo_viewer_opengl

```

**如果 C6 的延迟能降到 90ms 左右（接近 Vulkan），则本报告的所有推论都将得到完美的证实。**

---

## 实验 E7：呈现时间戳验证 (可选)

### 1. 实验目的

尝试获取物理呈现时间（Present Time），排除显示器本身延迟的不确定性。

### 2. 方法

* **Vulkan**: 使用 `VK_GOOGLE_display_timing` 扩展。
* **OpenGL**: 使用 `GLX_OML_sync_control` 扩展。
* *注：Linux 桌面环境（Compositor）可能会干扰这些扩展的准确性，建议在纯 X11 或直接 DRM 模式下测试，优先级较低。*

---

OpenGL+60Hz vs Vulkan+60Hz 验证实验计划
实验目标
验证核心假设：Vulkan的8.58ms额外延迟来自vkDeviceWaitIdle的过度同步
实验A：Vulkan同步策略对比实验
目的
直接验证vkDeviceWaitIdle对延迟的影响
实验设计
A1：移除vkDeviceWaitIdle
代码修改位置：VkDisplay.cpp 的 draw() 函数末尾
// 原代码（第1470行附近）
void VkDisplay::draw() {
    // ... 渲染代码 ...

    result = vkQueuePresentKHR(presentQueue, &presentInfo);

    // ===== 实验A1：注释掉这一行 =====
    // vkDeviceWaitIdle(device);  // 原始代码

    currentFrame = (currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;
}
测量方法：
# 使用相同的示波器光电传感器测量
# 记录40组数据，计算均值、方差
预期结果：
   指标
 原始Vulkan+60Hz
 A1预期
 说明

    均值
 154.64ms
 ~146ms
 接近OpenGL+60Hz

  方差
 41.16
 增大
 失去严格同步


结果解释：

如果延迟下降~8ms → 确认vkDeviceWaitIdle是主因

如果延迟不变 → 需要检查其他同步点

如果延迟下降但出现画面撕裂 → 需要实验A2

A2：替换为Fence等待
代码修改：
// VkDisplay.cpp draw()函数
void VkDisplay::draw() {
    // 等待上一帧完成（保留）
    vkWaitForFences(device, 1, &inFlightFences[currentFrame], VK_TRUE, UINT64_MAX);

    // ... 渲染代码 ...

    result = vkQueuePresentKHR(presentQueue, &presentInfo);

    // ===== 实验A2：替换同步策略 =====
    // 原始代码：vkDeviceWaitIdle(device);

    // 方案A2-1：仅等待呈现信号量（最轻量）
    // 无额外等待，依赖下一帧的vkWaitForFences

    // 方案A2-2：等待呈现队列空闲（中等）
    // vkQueueWaitIdle(presentQueue);

    currentFrame = (currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;
}
测试矩阵：
   方案
 同步策略
 预期延迟
 预期稳定性

    原始
 vkDeviceWaitIdle
 154.64ms
 高

  A2-1
 仅Fence
 ~140-145ms
 中

  A2-2
 vkQueueWaitIdle
 ~148-152ms
 中高


A3：增加MAX_FRAMES_IN_FLIGHT
代码修改：VkDisplay.h
// 原代码（第119行）
static constexpr int MAX_FRAMES_IN_FLIGHT = 1;

// ===== 实验A3：修改为2 =====
static constexpr int MAX_FRAMES_IN_FLIGHT = 2;
同时修改draw()保留vkDeviceWaitIdle：
void VkDisplay::draw() {
    vkWaitForFences(device, 1, &inFlightFences[currentFrame], VK_TRUE, UINT64_MAX);
    // ... 
    vkDeviceWaitIdle(device);  // 保留
    currentFrame = (currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;  // 现在是 % 2
}
预期：

延迟可能略微增加（多一帧缓冲）

但如果vkDeviceWaitIdle确实等待显示完成，增加缓冲深度不会改变行为

此实验用于区分"等待GPU"和"等待显示"

实验B：OpenGL添加强同步实验
目的
验证OpenGL快是因为缺少强同步（反向验证）
代码修改
位置：GLDisplay.cpp 的 renderWindowContext() 函数
void GLDisplay::renderWindowContext(int windowIndex) {
    glfwMakeContextCurrent(windows[windowIndex]);

    // ... 渲染代码 ...
    glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);

    glFinish();  // 原有的GPU等待

    // ===== 记录SwapBuffers前时间 =====
    auto pre_swap = std::chrono::steady_clock::now();

    glfwSwapBuffers(windows[windowIndex]);

    // ===== 实验B：添加强同步 =====
    // 方案B1：创建fence并立即等待
    GLsync sync = glFenceSync(GL_SYNC_GPU_COMMANDS_COMPLETE, 0);
    GLenum waitResult = glClientWaitSync(sync, GL_SYNC_FLUSH_COMMANDS_BIT, 
                                          1000000000ULL);  // 等待1秒超时
    glDeleteSync(sync);

    // ===== 记录同步后时间 =====
    auto post_sync = std::chrono::steady_clock::now();
    auto sync_duration = std::chrono::duration_cast<std::chrono::microseconds>(
        post_sync - pre_swap).count();
    printf("OPENGL_SYNC_WAIT: %ld us\n", sync_duration);

    glfwMakeContextCurrent(NULL);
}
更激进的方案B2：
// 在SwapBuffers后强制等待下一个VSync
glfwSwapBuffers(windows[windowIndex]);

// 方案B2：再次调用SwapBuffers等待VSync（模拟vkDeviceWaitIdle行为）
// 注意：这会导致跳帧，仅用于延迟测量
glFinish();  // 确保当前帧的GPU命令完成

// 或者使用GLX/EGL扩展等待VSync（如果可用）
// glXWaitVideoSyncSGI(...);
预期结果：
   方案
 预期延迟
 说明

    原始OpenGL+60Hz
 146.06ms
 基准

  B1 (fence等待)
 ~150-155ms
 应接近Vulkan

  B2 (双SwapBuffers)
 ~160-165ms
 可能更慢


结果解释：

B1延迟增加到~154ms → 确认同步策略是差异主因

B1延迟变化不大 → 差异可能来自其他因素（如CPU处理）

实验C：帧周期精确测量
目的
测量实际帧处理周期，验证Vulkan帧周期是否真的更长
代码修改
C1：Vulkan帧周期测量
位置：endo_viewer.cpp 的 show() 函数（Vulkan循环）
// 在Vulkan主循环开始处添加
static std::chrono::steady_clock::time_point last_frame_start;
static bool first_frame = true;
static std::vector<long> frame_periods;

while (!vkDisplay->shouldClose()) {
    auto frame_start = ::getCurrentTimePoint();

    // ===== 帧周期测量 =====
    if (!first_frame) {
        long period = std::chrono::duration_cast<std::chrono::microseconds>(
            frame_start - last_frame_start).count();
        frame_periods.push_back(period);
        printf("VK_FRAME_PERIOD: %ld us\n", period);
    }
    first_frame = false;
    last_frame_start = frame_start;

    // ... 原有代码 ...

    vkDisplay->draw();

    // ===== 在循环末尾统计 =====
    if (frame_periods.size() >= 100 && frame_periods.size() % 100 == 0) {
        double sum = 0;
        for (auto p : frame_periods) sum += p;
        double avg = sum / frame_periods.size();
        printf("VK_AVG_FRAME_PERIOD: %.2f us (%.2f ms)\n", avg, avg/1000.0);
    }
}
C2：OpenGL帧周期测量
位置：GLDisplay.cpp 的 renderWindowContext() 或 endo_viewer.cpp 的OpenGL循环
// 在OpenGL主循环添加类似的测量代码
static std::chrono::steady_clock::time_point last_frame_start;
static bool first_frame = true;

// 在renderWindowContext开始处
if (windowIndex == 0) {  // 只在第一个窗口测量
    auto frame_start = std::chrono::steady_clock::now();
    if (!first_frame) {
        long period = std::chrono::duration_cast<std::chrono::microseconds>(
            frame_start - last_frame_start).count();
        printf("GL_FRAME_PERIOD: %ld us\n", period);
    }
    first_frame = false;
    last_frame_start = frame_start;
}
预期结果
   配置
 预期平均帧周期
 说明

    Vulkan+60Hz
 ~22-25ms
 受vkDeviceWaitIdle限制

  OpenGL+60Hz
 ~13-16ms
 CPU/GPU可重叠


数据分析
# 分析脚本示例
import numpy as np

vk_periods = [...]  # 从日志提取
gl_periods = [...]

print(f"Vulkan 帧周期: 均值={np.mean(vk_periods):.2f}us, 标准差={np.std(vk_periods):.2f}us")
print(f"OpenGL 帧周期: 均值={np.mean(gl_periods):.2f}us, 标准差={np.std(gl_periods):.2f}us")

# 绘制直方图对比
import matplotlib.pyplot as plt
plt.hist(vk_periods, bins=50, alpha=0.5, label='Vulkan')
plt.hist(gl_periods, bins=50, alpha=0.5, label='OpenGL')
plt.legend()
plt.savefig('frame_period_comparison.png')
实验D：GPU时间戳精确测量
目的
分离CPU处理时间、GPU渲染时间、同步等待时间
D1：Vulkan时间戳查询
代码修改：VkDisplay.cpp
// 在类中添加成员变量（VkDisplay.h）
VkQueryPool timestampQueryPool;
uint64_t timestampPeriod;  // 纳秒/时间戳单位

// 初始化（在init()中添加）
void VkDisplay::createTimestampQueryPool() {
    // 获取时间戳周期
    VkPhysicalDeviceProperties properties;
    vkGetPhysicalDeviceProperties(physicalDevice, &properties);
    timestampPeriod = properties.limits.timestampPeriod;
    printf("Timestamp period: %f ns\n", timestampPeriod);

    // 创建查询池（4个时间戳：开始、上传后、渲染后、呈现后）
    VkQueryPoolCreateInfo queryPoolInfo{};
    queryPoolInfo.sType = VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO;
    queryPoolInfo.queryType = VK_QUERY_TYPE_TIMESTAMP;
    queryPoolInfo.queryCount = 4;

    vkCreateQueryPool(device, &queryPoolInfo, nullptr, &timestampQueryPool);
}

// 在recordCommandBuffer中插入时间戳
void VkDisplay::recordCommandBuffer(VkCommandBuffer commandBuffer, uint32_t imageIndex) {
    VkCommandBufferBeginInfo beginInfo{};
    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    vkBeginCommandBuffer(commandBuffer, &beginInfo);

    // ===== 时间戳0：命令缓冲开始 =====
    vkCmdResetQueryPool(commandBuffer, timestampQueryPool, 0, 4);
    vkCmdWriteTimestamp(commandBuffer, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, 
                        timestampQueryPool, 0);

    // ... 纹理上传代码 ...

    // ===== 时间戳1：纹理上传后 =====
    vkCmdWriteTimestamp(commandBuffer, VK_PIPELINE_STAGE_TRANSFER_BIT,
                        timestampQueryPool, 1);

    // ... 渲染代码 ...
    vkCmdEndRenderPass(commandBuffer);

    // ===== 时间戳2：渲染完成 =====
    vkCmdWriteTimestamp(commandBuffer, VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
                        timestampQueryPool, 2);

    vkEndCommandBuffer(commandBuffer);
}

// 在draw()中读取时间戳
void VkDisplay::draw() {
    vkWaitForFences(...);

    // ===== 读取上一帧的时间戳 =====
    uint64_t timestamps[4];
    VkResult result = vkGetQueryPoolResults(device, timestampQueryPool, 
                                            0, 4, sizeof(timestamps), timestamps,
                                            sizeof(uint64_t), VK_QUERY_RESULT_64_BIT);
    if (result == VK_SUCCESS) {
        double upload_time = (timestamps[1] - timestamps[0]) * timestampPeriod / 1e6;
        double render_time = (timestamps[2] - timestamps[1]) * timestampPeriod / 1e6;
        printf("VK_GPU_TIMING: upload=%.2fms, render=%.2fms\n", upload_time, render_time);
    }

    // ... 其余代码 ...

    auto pre_wait = std::chrono::steady_clock::now();
    vkDeviceWaitIdle(device);
    auto post_wait = std::chrono::steady_clock::now();

    long wait_time = std::chrono::duration_cast<std::chrono::microseconds>(
        post_wait - pre_wait).count();
    printf("VK_DEVICE_WAIT_IDLE: %ld us\n", wait_time);
}
D2：OpenGL时间戳查询
代码修改：GLDisplay.cpp
// 在类中添加成员变量（GLDisplay.h）
GLuint timeQueryObjects[3];  // 开始、渲染后、SwapBuffers后

// 初始化（在init()中）
void GLDisplay::initTimerQueries() {
    glGenQueries(3, timeQueryObjects);
}

// 在renderWindowContext中使用
void GLDisplay::renderWindowContext(int windowIndex) {
    glfwMakeContextCurrent(windows[windowIndex]);

    // ===== 查询0：开始 =====
    glQueryCounter(timeQueryObjects[0], GL_TIMESTAMP);

    // ... 渲染代码 ...
    glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);

    // ===== 查询1：渲染命令发出后 =====
    glQueryCounter(timeQueryObjects[1], GL_TIMESTAMP);

    glFinish();

    // ===== 查询2：glFinish后 =====
    glQueryCounter(timeQueryObjects[2], GL_TIMESTAMP);

    glfwSwapBuffers(windows[windowIndex]);

    // 读取时间戳（下一帧读取，确保结果可用）
    GLuint64 startTime, renderTime, finishTime;
    glGetQueryObjectui64v(timeQueryObjects[0], GL_QUERY_RESULT, &startTime);
    glGetQueryObjectui64v(timeQueryObjects[1], GL_QUERY_RESULT, &renderTime);
    glGetQueryObjectui64v(timeQueryObjects[2], GL_QUERY_RESULT, &finishTime);

    double cmd_issue = (renderTime - startTime) / 1e6;    // ms
    double gpu_exec = (finishTime - renderTime) / 1e6;    // ms
    printf("GL_GPU_TIMING: cmd_issue=%.2fms, gpu_exec=%.2fms\n", cmd_issue, gpu_exec);

    glfwMakeContextCurrent(NULL);
}
预期数据格式
VK_GPU_TIMING: upload=0.45ms, render=2.10ms
VK_DEVICE_WAIT_IDLE: 14500 us
VK_FRAME_PERIOD: 22300 us

GL_GPU_TIMING: cmd_issue=0.12ms, gpu_exec=3.20ms
GL_FRAME_PERIOD: 14100 us
实验E：VSync禁用对比实验
目的
排除VSync对延迟差异的影响
E1：Vulkan禁用VSync
代码修改：VkDisplay.cpp 的 chooseSwapPresentMode()
VkPresentModeKHR VkDisplay::chooseSwapPresentMode(
    const std::vector<VkPresentModeKHR>& availablePresentModes) {

    // ===== 实验E1：强制使用IMMEDIATE模式（无VSync） =====
    for (const auto& mode : availablePresentModes) {
        if (mode == VK_PRESENT_MODE_IMMEDIATE_KHR) {
            std::cout << "Using IMMEDIATE Mode (No VSync - Experiment E1)" << std::endl;
            return mode;
        }
    }

    // 原始代码作为fallback
    // ...
}
同时保留vkDeviceWaitIdle，观察其在无VSync时的等待时间。
E2：OpenGL禁用VSync
代码修改：GLDisplay.cpp 的 initGLFW()
bool GLDisplay::initGLFW(int width, int height, std::string title, int numWindows) {
    // ...
    glfwMakeContextCurrent(windows[0]);

    // ===== 实验E2：禁用VSync =====
    glfwSwapInterval(0);  // 原来是1

    // ...
}
预期结果
   配置
 VSync开启
 VSync关闭
 差异

    Vulkan+60Hz
 154.64ms
 ~140-145ms
 -10~15ms

  OpenGL+60Hz
 146.06ms
 ~135-140ms
 -6~11ms

  Vulkan vs OpenGL
 +8.58ms
 预测：~0-5ms
 差距缩小


结果解释：

如果差距缩小到<5ms → VSync相关同步是主因

如果差距仍在8ms左右 → vkDeviceWaitIdle有VSync之外的等待内容

实验F：CPU/GPU重叠度测量
目的
直接验证OpenGL是否允许CPU提前准备下一帧
代码修改
在两种渲染循环中添加重叠检测：
// 通用结构
struct FrameTiming {
    std::chrono::steady_clock::time_point cpu_start;
    std::chrono::steady_clock::time_point cpu_end;
    std::chrono::steady_clock::time_point frame_complete;
};

std::vector<FrameTiming> frame_timings;

// Vulkan循环
while (!vkDisplay->shouldClose()) {
    FrameTiming timing;
    timing.cpu_start = std::chrono::steady_clock::now();

    vkDisplay->pollEvents();
    // ... buffer check, updateVideo ...

    timing.cpu_end = std::chrono::steady_clock::now();

    vkDisplay->draw();  // 包含vkDeviceWaitIdle

    timing.frame_complete = std::chrono::steady_clock::now();
    frame_timings.push_back(timing);
}

// 分析重叠度
for (size_t i = 1; i < frame_timings.size(); i++) {
    auto& prev = frame_timings[i-1];
    auto& curr = frame_timings[i];

    // 检查：当前帧CPU开始时间 vs 上一帧完成时间
    long overlap = std::chrono::duration_cast<std::chrono::microseconds>(
        prev.frame_complete - curr.cpu_start).count();

    // overlap > 0 表示有重叠（当前帧CPU在上一帧完成前就开始了）
    // overlap <= 0 表示串行（当前帧CPU在上一帧完成后才开始）
    printf("FRAME_OVERLAP: %ld us (%s)\n", overlap, 
           overlap > 0 ? "OVERLAPPED" : "SERIAL");
}
预期结果
   配置
 重叠情况
 说明

    Vulkan
 100%串行（overlap≤0）
 vkDeviceWaitIdle阻塞

  OpenGL
 部分重叠（overlap>0）
 SwapBuffers后立即返回


实验执行计划
阶段1：基础对比实验（第1-2天）
   序号
 实验
 修改量
 优先级

    1
 C1+C2：帧周期测量
 小
 最高

  2
 E1+E2：禁用VSync
 小
 高

  3
 A1：移除vkDeviceWaitIdle
 1行
 高


执行顺序：
Day 1 上午：实施C1+C2，采集Vulkan和OpenGL的帧周期数据
Day 1 下午：实施E1+E2，采集无VSync的延迟数据
Day 2 上午：实施A1，采集移除vkDeviceWaitIdle后的延迟数据
Day 2 下午：数据分析，确定是否需要进一步实验
阶段2：深入分析实验（第3-4天）
   序号
 实验
 修改量
 条件

    4
 D1+D2：GPU时间戳
 中
 如果阶段1结果不明确

  5
 B1：OpenGL添加强同步
 小
 反向验证

  6
 F：重叠度测量
 中
 验证流水线假设


阶段3：替代方案测试（第5天）
   序号
 实验
 目的

    7
 A2-1：仅Fence等待
 寻找最优Vulkan配置

  8
 A2-2：vkQueueWaitIdle
 中间方案

  9
 A3：增加帧缓冲深度
 测试多缓冲影响


数据记录模板
每组实验记录
## 实验 [编号]：[名称]

### 配置
- 日期时间：
- 代码版本/commit：
- 修改内容：

### 环境
- 显示器刷新率：60Hz
- 相机帧率：60Hz
- VSync状态：开启/关闭

### 原始数据
| 序号 | 端到端延迟(ms) | 帧周期(us) | 备注 |
|------|----------------|------------|------|
| 1    |                |            |      |
| ...  |                |            |      |
| 40   |                |            |      |

### 统计结果
- 均值：
- 标准差：
- 极大值：
- 极小值：

### 控制台日志摘要
（粘贴关键日志）
### 结论
- 支持/反驳假设：
- 新发现：
结果判定标准
假设验证矩阵
   假设
 验证实验
 支持条件
 反驳条件

    vkDeviceWaitIdle导致额外8ms
 A1
 移除后差距<3ms
 移除后差距仍>6ms

  OpenGL允许CPU/GPU重叠
 F
 检测到overlap>0
 100%串行

  VSync是差异的一部分
 E1+E2
 禁用后差距缩小>3ms
 差距变化<2ms

  OpenGL驱动有帧缓冲
 B1
 添加同步后延迟增加>5ms
 变化<3ms


最终结论判定
如果 A1支持 AND F支持：
    → 确认"vkDeviceWaitIdle过度同步"是8.58ms差异的主因（高置信度）

如果 A1支持 BUT F反驳：
    → vkDeviceWaitIdle是主因，但机制不是CPU/GPU重叠（需要修正分析）

如果 A1反驳：
    → 需要重新分析差异来源（可能是驱动层面的差异）